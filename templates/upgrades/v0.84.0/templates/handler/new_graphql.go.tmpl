package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"

	"{{.ModulePath}}/graph"
	"{{.ModulePath}}/graph/directive"
	"{{.ModulePath}}/graph/generated"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/99designs/gqlgen/graphql/handler/extension"
	"github.com/99designs/gqlgen/graphql/handler/transport"
	"github.com/aws/aws-lambda-go/events"
	"github.com/tilotech/go-plugin"
	"github.com/tilotech/tilores-plugin-api/dispatcher"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// HandleGraphQLRequest is the entry point when started in a lambda function
func HandleGraphQLRequest(ctx context.Context, request *events.APIGatewayProxyRequest) (json.RawMessage, error) {
	initAdapter()

	ctx, err := directive.PreparePrivilegeContext(ctx, request)
	if err != nil {
		fmt.Println(err)
		return proxyErrorJSON(err, 500), nil
	}

	r := requestFromProxy(ctx, request)
	r = r.WithContext(ctx)
	w := newResponseWriter(r)
	adapter.ServeHTTP(w, r)

	return w.asProxyResponseJSON(), err
}

var adapter http.HandlerFunc

func initAdapter() {
	if adapter != nil {
		return
	}

	// term function ignored, because the plugin should never shut down unless the
	// lambda function does
	pluginPath := os.Getenv("DISPATCHER_PLUGIN_PATH")
	dsp, _, err := dispatcher.Connect(
		plugin.StartWithCmd(func() *exec.Cmd {
			return exec.Command(pluginPath)
		}),
		plugin.DefaultConfig(),
	)
	if err != nil {
		panic(err)
	}

	gqlConfig := generated.Config{
		Resolvers: &graph.Resolver{
			Dispatcher: dsp,
		},
	}

	gqlConfig.Directives.HasPrivilege = directive.HasPrivilege

	schema := generated.NewExecutableSchema(gqlConfig)
	srv := handler.New(schema)
	srv.AddTransport(transport.POST{})
	srv.Use(extension.Introspection{})
	srv.SetErrorPresenter(func(ctx context.Context, e error) *gqlerror.Error {
		fmt.Printf("error: %v\n", e)
		return graphql.DefaultErrorPresenter(ctx, e)
	})
	adapter = srv.ServeHTTP
}
